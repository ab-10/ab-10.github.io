---
layout: post
title: "Reverse Engineering Blaude Code"
hidden: True
date: 2025-07-01 10:00:00 +00000
---

Using Claude Code feels like magic.
This blog post will walk guide you from being a bewildered attendee of a magic show to the magician on stage.
Of course, this work is a homage to the original magicians -- the Claude Code team at Anthropic!
Claude Code is powered by a huge set of clever engineering innovations and smart hacks.
This post only scratches the surface and gives you, the reader, the tools to dig further!

First, let's address the complaints by legal department!
Reverse engineering Claude Code would violate their terms of service.
That's why we'll use Blaude Code instead.
It's a similar piece of software that I came across:

![Terminal screenshot saying "Welcome to Blaude Code"](../assets/blaude/welcome.png)

Great, now that we're in good legal standing, we can start intercepting API requests.



## mitmproxy setup

We'll use `mitmproxy` to inspect requests blaude is sending to the Anthropic API.

```bash
mitmweb --mode reverse:https://api.anthropic.com --listen-port 8000
ANTHROPIC_BASE_URL=http://localhost:8000/ blaude # replace blaude with claude at your own peril
```

Now you can inspect the requests created with blaude code in http://127.0.0.1:8081/.
The instructions in this blogpost work just fine on Claude Code.
However, that would violate Anthropic's ToS, so we're not going to do that!

## The system prompt

_You can find the full system prompt [here](https://gist.github.com/ab-10/312fdbcaf1b4158645aa8ad8b74c35d6)_

First thing that stands out in the intercepted request is the system prompt.
It's mostly a static instruction defining Blaude's behaviour, with some dynamically added context.

### Static Parts

**The preamble:** this is what you'd expect. It defines the "persona" for the agent.

"You are an interactive CLI tool that helps users with software engineering tasks. Use the instructions below and the tools available to you to assist the user..."

I found the other sections to be particularly instrumental in creating a good interactive LLM experience.

**Tone and style:**

"You should be concise, direct, and to the point. You MUST answer concisely with fewer than 4 lines (not including tool use or code generation), unless user asks for detail..."

**Proactiveness:**

"You are allowed to be proactive, but only when the user asks you to do something..."

**Following conventions:**

"When making changes to files, first understand the file's code conventions..."


### Dynamic Codebase Context

**Code style:** user-defined rules.

## Defined Tools

### Bash

**Name:** Bash  

**Description:** Executes bash commands in a persistent shell session with optional timeout, ensuring proper handling and security measures.  

**Arguments:** command (string), timeout (number, optional), description (string, optional)

### Glob

**Name:** Glob  

**Description:** Fast file pattern matching tool that works with any codebase size. Supports glob patterns like "**/*.js" and returns matching file paths sorted by modification time.  

**Arguments:** pattern (string), path (string, optional)

### Grep

**Name:** Grep  

**Description:** A powerful search tool built on ripgrep that supports full regex syntax, file filtering, and various output modes for searching file contents.  

**Arguments:** pattern (string), path (string, optional), glob (string, optional), output_mode (enum, optional), -B (number, optional), -A (number, optional), -C (number, optional), -n (boolean, optional), -i (boolean, optional), type (string, optional), head_limit (number, optional), multiline (boolean, optional)

### LS

**Name:** LS  

**Description:** Lists files and directories in a given path. Must use absolute paths and can optionally ignore files matching glob patterns.  

**Arguments:** path (string), ignore (array of strings, optional)

### ExitPlanMode

**Name:** ExitPlanMode  

**Description:** Use when in plan mode and ready to exit after presenting implementation plans for coding tasks.  

**Arguments:** plan (string)

### Read

**Name:** Read  

**Description:** Reads files from the local filesystem, including text files, images, and PDFs. Returns content with line numbers and supports partial reading with offset/limit.  

**Arguments:** file_path (string), offset (number, optional), limit (number, optional)

### Edit

**Name:** Edit  

**Description:** Performs exact string replacements in files. Requires reading the file first and matches must be unique unless using replace_all.  

**Arguments:** file_path (string), old_string (string), new_string (string), replace_all (boolean, optional)

### MultiEdit

**Name:** MultiEdit  

**Description:** Makes multiple edits to a single file in one operation. Applies edits sequentially and all must succeed or none are applied.  

**Arguments:** file_path (string), edits (array of edit objects)

### Write

**Name:** Write  

**Description:** Writes content to files, overwriting existing files. Must read existing files first before overwriting.  

**Arguments:** file_path (string), content (string)

### NotebookRead

**Name:** NotebookRead  

**Description:** Reads Jupyter notebook files and returns all cells with their outputs. Can read specific cells by ID.  

**Arguments:** notebook_path (string), cell_id (string, optional)

### NotebookEdit

**Name:** NotebookEdit  

**Description:** Replaces contents of specific cells in Jupyter notebooks. Supports replace, insert, and delete operations.  

**Arguments:** notebook_path (string), cell_id (string, optional), new_source (string), cell_type (enum, optional), edit_mode (enum, optional)

### WebFetch

**Name:** WebFetch  

**Description:** Fetches content from URLs and processes it with AI, converting HTML to markdown and analyzing based on provided prompts.  

**Arguments:** url (string), prompt (string)

### WebSearch

**Name:** WebSearch  

**Description:** Searches the web and uses results to inform responses, providing up-to-date information beyond Blaude's knowledge cutoff.  

**Arguments:** query (string), allowed_domains (array of strings, optional), blocked_domains (array of strings, optional)

### Task

**Name:** Task  

**Description:** Launch a new agent to handle complex, multi-step tasks autonomously. The general-purpose agent can research complex questions, search for code, and execute multi-step tasks.  

**Arguments:** description (string), prompt (string), subagent_type (string)


### TodoWrite

**Name:** TodoWrite  

**Description:** Creates and manages structured task lists for coding sessions to track progress and organize complex multi-step tasks.  

**Arguments:** todos (array of todo objects with content, status, priority, and id)



## Incremental Parsing

## TODO Multi-Step Hack

The most remarkable thing about Blaude Code, is that you can just leave it running and come back to a finished implementation (most of the time):

![@yoav.codes: Great time to be alive. I ask claude code to do something with the same detail I'd have given a staff engineer back when I was a tech lead in a big company. It goes off for 20 minutes searching, understanding, iterating, and writes the code exactly as I would 2x as fast while I play with my dog.](../assets/blaude/post.png)

There are two core mechanisms to this (beyond just good foundation model performance):
1. TODO lists (this section).
2. Automatic context summarization.


If you've used Blaude Code on any non-trivial task, you probably have noticed that it displays and tracks a TODO list:

![Blaude Code's TODO list](../assets/blaude/todo_list.png)

This is a clever multi-step agent hack.
Here's the workflow:

1. LLM makes a tool-call to a TODO tool.
    This either creates new tasks or updates the status of existing ones.
2. If there are pending tasks, LLM keeps running until all tasks are complete.

Step (2.) is my rough guess.
There are probably limits in place.
The tasks also have priority associated with them, so I wouldn't be surprised if task priority and count are used under the hood.
But this is the core mechanism!


### TODO Tool

The TODO tool accepts a list of Tasks, each Task must have the following:
- **content**: The task description (minimum 1 character)
- **status**: One of "pending", "in_progress", or "completed" 
- **priority**: One of "high", "medium", or "low"
- **id**: A unique identifier for the task

The tool has an extensive description.
I've saved it [here](https://gist.github.com/ab-10/241828d1876189ba1dbe38751c245f14).

The response is nothing profound: "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"

Confused?
If you haven't seen similar tools before, the idea of a tool, that doesn't give a particularly insightful response might be counter-intuitive.
This is definitely different from an LLM tool in the traditional sense (e.g. web search or `ls`), where the tool is a way for LLM to request more context.
Here it's more akin to either:
1. [Forcing structured output](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview#json-mode) through tool use.
2. [Think tool](https://www.anthropic.com/engineering/claude-think-tool).

### Example Run

**Original query:** Reimplement the functionality of fastAPI backend (under backend/) using C instead of Python

**Agent creates the TODO list:**

```json
{
    "type": "tool_use",
    "id": "toolu_013CYRJHt2MK2FeFNLZmCFxK",
    "name": "TodoWrite",
    "input": {
        "todos": [
            {
                "id": "1",
                "content": "Explore existing FastAPI backend structure and functionality",
                "status": "pending",
                "priority": "high"
            },
            {
                "id": "2",
                "content": "Analyze API endpoints and their logic",
                "status": "pending",
                "priority": "high"
            },
            {
                "id": "3",
                "content": "Design C implementation architecture",
                "status": "pending",
                "priority": "medium"
            },
            {
                "id": "4",
                "content": "Implement C backend with equivalent functionality",
                "status": "pending",
                "priority": "high"
            },
            {
                "id": "5",
                "content": "Test the C implementation",
                "status": "pending",
                "priority": "medium"
            }
        ]
    }
}
```

**Response:** TODO tool call response is always a generic confirmation.

```json
{
    "role": "user",
    "content": [
        {
            "tool_use_id": "toolu_013CYRJHt2MK2FeFNLZmCFxK",
            "type": "tool_result",
            "content": "Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"
        }
    ]
}
```

**Implementation flow:**
First, it marks task #1 as "in_progress" and begins exploring the codebase with `LS` to understand the project structure.
It discovers there's already a `C/` directory alongside the original `backend/` folder.

Then, Blaude uses the `Read` tool to examine the FastAPI implementation piece by piece: the main application setup with its CORS configuration and Logfire instrumentation, the API routing structure, and each individual route file for login, users, and items.

Blaude updates its TODO status as it goes.
It repeats this cycle for every task item.


**Pausing/finish:** Blaude pauses when either user confirmation is required (for executing commands) or the task is finished.
It first paused, waiting for me to confirm deleting `C/` directory (it was left over from a previous trial run).
Finally, the full task list was complete:

```json
{
    "type": "tool_use",
    "id": "toolu_013CYRJHt2MK2FeFNLZmCFxK",
    "name": "TodoWrite",
    "input": {
        "todos": [
            {
                "id": "1",
                "content": "Explore existing FastAPI backend structure and functionality",
                "status": "complete",
                "priority": "high"
            },
            {
                "id": "2",
                "content": "Analyze API endpoints and their logic",
                "status": "complete",
                "priority": "high"
            },
            {
                "id": "3",
                "content": "Design C implementation architecture",
                "status": "complete",
                "priority": "medium"
            },
            {
                "id": "4",
                "content": "Implement C backend with equivalent functionality",
                "status": "complete",
                "priority": "high"
            },
            {
                "id": "5",
                "content": "Test the C implementation",
                "status": "complete",
                "priority": "medium"
            }
        ]
    }
}
```

## Automatic Context Summarization


## File Editing
